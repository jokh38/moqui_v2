#ifndef MQI_BEAM_MODULE_ION_H
#define MQI_BEAM_MODULE_ION_H

/// \file mqi_beam_module_ion.hpp
///
/// \brief Interprets DICOM-RT Ion beam modules for plans and treatment records.
///
/// \details
/// This file provides the `beam_module_ion` class, which is responsible for parsing
/// and managing data from DICOM-RT Ion Plan (RTI) and Ion Beam Treatment Record (RTIBTR)
/// modules. DICOM-RT is a standard for storing and transmitting medical imaging information,
/// including radiotherapy plans. This class extracts crucial information for simulating
/// ion beam therapy, such as scan spots, energies, and weights.
///
/// For a Python developer, you can think of this file as defining a "parser" class that
/// reads a specific, complex data format (DICOM-RT) and organizes it into a more
/// accessible structure for use in the simulation.
///
/// The `#ifndef MQI_BEAM_MODULE_ION_H` and `#define MQI_BEAM_MODULE_ION_H` lines are
/// "header guards." They prevent the C++ compiler from including this file more than
/// once in a single compilation, which would cause errors.
///
/// \see http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.8.25.html for RTI
/// \see http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.8.26.html for RTIBTR

#include <moqui/base/mqi_beam_module.hpp>

// The `namespace mqi` block is used to group related code together and avoid naming
// conflicts with other libraries. It's similar to how Python uses modules to
// organize code. All code within this namespace must be accessed with the `mqi::` prefix
// from outside the namespace.
namespace mqi
{

/// \enum SCAN_MODE
/// \brief Defines the scan mode for an ion beam, based on DICOM tag (300A,0308).
/// \details In C++, an `enum` (enumeration) is a user-defined type consisting of a set
/// of named integer constants. It's useful for representing a fixed set of options,
/// making the code more readable and less error-prone than using raw integers.
typedef enum {
    NONE           = 0, ///< No scan mode specified.
    UNIFORM        = 1, ///< Uniform scanning, where the beam covers the target area evenly.
    MODULATED      = 2, ///< Modulated scanning, where the beam intensity is varied.
    MODULATED_SPEC = 3  ///< Modulated scanning with specific, detailed parameters.
} SCAN_MODE;

/// \struct logfile_t
/// \brief Represents data for a single field in a treatment log file.
/// \details A `struct` in C++ is a way to group several related variables into one place.
/// It's similar to a simple Python class without methods or a dictionary-like object.
/// This struct holds data from log files generated by the treatment machine, which
/// record the actual delivered beam spots.
/// \note Added by Chanil Jeon of SMC (Samsung Medical Center) (2023-11-02).
struct logfile_t
{
    ///< `std::vector` is a C++ standard library template for a dynamic array, much like a Python list.
    std::vector<float> posX;    ///< X-positions of spots in mm.
    std::vector<float> posY;    ///< Y-positions of spots in mm.
    std::vector<int>   muCount; ///< Monitor units or particle counts for each spot.
};

/// \struct logfiles_t
/// \brief Represents data for all energy layers in a treatment log file.
/// \details This struct aggregates `logfile_t` data for multiple energy layers of a treatment.
/// An ion beam treatment is delivered layer-by-layer, where each layer has a specific energy.
/// \note Added by Chanil Jeon of SMC (Samsung Medical Center) (2023-11-02).
struct logfiles_t
{
    ///< A vector of vectors, similar to a list of lists in Python.
    std::vector<std::vector<float>>   beamEnergyInfo; ///< Information about beam energy for each layer.
    std::vector<std::vector<logfile_t>> beamInfo;       ///< Detailed spot information for each layer.
};

/// \class beam_module_ion
/// \brief A class for handling RT-ION beams from DICOM plans and treatment records.
///
/// \details This class inherits from `beam_module` (indicated by `: public beam_module`) and
/// specializes in parsing the Ion Control Point Sequence from DICOM-RT Ion objects.
/// In object-oriented terms, `beam_module_ion` is a "child" or "subclass" of `beam_module`.
/// It extracts all necessary parameters for simulating a pencil beam scanning treatment,
/// including spot positions, energies, FWHM (beam width), and meterset weights (beam intensity).
class beam_module_ion : public beam_module
{
public:
    /// \struct spot
    /// \brief A user-defined type representing a single scan spot's planned parameters.
    /// \details `typedef struct` creates an alias for the struct, making it easier to use.
    /// This struct defines the planned properties of a single pencil beam spot.
    typedef struct {
        float e;        ///< The spot energy in MeV (Mega-electron Volts).
        float x;        ///< The planned x-position in the gantry coordinate system (in mm).
        float y;        ///< The planned y-position in the gantry coordinate system (in mm).
        float fwhm_x;   ///< The Full-Width at Half-Maximum (a measure of beam width) in the x-direction (in mm).
        float fwhm_y;   ///< The Full-Width at Half-Maximum in the y-direction (in mm).
        float meterset; ///< The meterset weight, proportional to the number of particles to be delivered.
    } spot;

    /// \struct logspot
    /// \brief Represents a single spot from a treatment log file for MC simulation.
    /// \details This struct holds data for a spot as it was actually delivered, according to
    /// the machine's log files. This can be used for quality assurance or for simulations
    /// based on the delivered treatment rather than the planned one.
    /// \note Added in 2023 for SMC Log-file based MC simulation.
    typedef struct {
        float e;       ///< The spot energy in MeV.
        float x;       ///< The delivered x-position in mm.
        float y;       ///< The delivered y-position in mm.
        float muCount; ///< The particle count, derived from the meterset, for Monte Carlo simulation.
    } logspot;

protected:
    /// `protected:` members are like `private:` members but they can be accessed by
    /// child classes (subclasses).

    /// \brief A vector containing the number of spots in each energy layer.
    /// `std::vector<int>` is a dynamic array of integers, like a Python list of ints.
    std::vector<int> nb_spots_per_layer_;

    /// \brief A vector containing all spots in the order they are delivered.
    /// This stores a sequence of the `spot` structs defined above.
    std::vector<spot> sequence_;

    /// \brief The name of the beam model or tune ID from the treatment planning system.
    /// `std::string` is the C++ equivalent of a Python string.
    std::string tune_id_;

public:
    /// `public:` members and methods can be accessed from anywhere outside the class.

    /// \brief Constructs a beam module for RT-Ion.
    ///
    /// \details This constructor parses the provided DICOM dataset to extract the ion beam
    /// parameters. It handles both plan (IONPLAN) and treatment record (IONRECORD)
    /// modalities. A constructor is a special method that is automatically called
    /// when an object of this class is created.
    ///
    /// \param d A pointer to the DICOM dataset, which should be an item from the
    ///          IonBeamSequence for a plan (C.8.8.25-1) or a record (C.8.8.26-1).
    ///          In C++, a pointer (`*`) is a variable that stores a memory address.
    /// \param m The modality type, which must be either `IONPLAN` or `IONRECORD`.
    beam_module_ion(const mqi::dataset* d, mqi::modality_type m) : beam_module(d, m) {
        /// Initializes containers to store data extracted from the DICOM file.
        /// `std::vector<type>(size)` creates a vector of a given size.
        std::vector<int>         nb_pts(1);
        std::vector<float>       energy(1);
        std::vector<float>       fwhm_xy(2);
        std::vector<std::string> tune_id(1);
        std::vector<float>       xy;
        std::vector<float>       weight;

        int layer_nb = 0;

        std::string str_weight;

        /// Checks modality type to determine which DICOM tag to use for spot weights.
        switch (modality_) {
        case mqi::modality_type::IONPLAN:
            // For plans, weights are the intended meterset values.
            str_weight = "ScanSpotMetersetWeights";
            break;
        case mqi::modality_type::IONRECORD:
            // For records, weights are the meterset values that were actually delivered.
            str_weight = "ScanSpotMetersetsDelivered";
            break;
        default:
            // If the modality is neither, throw an error. This is a form of error handling.
            throw std::runtime_error("Wrong ION type");
        }

        /// Fill the containers from the DICOM dataset.
        /// The Ion Control Point Sequence in DICOM contains pairs of control points for each
        /// energy layer. The second control point in each pair often contains redundant or
        /// zero-weight information, so this code only processes the first one (even-numbered layer_nb).
        auto seq_tags = &mqi::seqtags_per_modality.at(m);
        auto ictrl    = (*ds_)(seq_tags->at("ctrl"));
        for (auto b : ictrl) {   // Loop through each control point in the sequence.

            // The `(layer_nb++) % 2` logic skips every other entry (the odd-numbered ones).
            if ((layer_nb++) % 2) continue;

            // Extract data for the current layer using DICOM tags (string keys).
            b->get_values("ScanSpotTuneID", tune_id);
            b->get_values("NominalBeamEnergy", energy);
            b->get_values("NumberOfScanSpotPositions", nb_pts);
            b->get_values("ScanningSpotSize", fwhm_xy);
            b->get_values("ScanSpotPositionMap", xy);
            b->get_values(str_weight.c_str(), weight);

            // Loop through each spot in the current energy layer.
            for (int j = 0; j < nb_pts[0]; ++j) {
                tune_id_ = tune_id[0];
                // Create a `spot` struct and add it to the `sequence_` vector.
                sequence_.push_back(
                  { energy[0], xy[j * 2], xy[j * 2 + 1], fwhm_xy[0], fwhm_xy[1], weight[j] });
            }   //per spot
            // Record the number of spots found in this layer.
            nb_spots_per_layer_.push_back(nb_pts[0]);
        }   //per layer
    }

    /// \brief Destroys the beam_module_ion object.
    /// \details A destructor is a special method called when an object is destroyed or
    /// goes out of scope. It's used for cleanup, like freeing memory. This one is empty
    /// because the standard library containers (`vector`, `string`) handle their own memory.
    ~beam_module_ion() {
        ;
    }

    /// \brief Returns a constant pointer to the vector of spot counts per layer.
    /// \details The `const` keyword is used extensively. `const std::vector<int>*` means
    /// it returns a pointer to a vector of ints that cannot be modified through this pointer.
    /// The `const` at the end of the function signature means this method does not modify
    /// the state of the `beam_module_ion` object.
    /// \return A pointer to a vector where each element is the number of spots
    ///         in the corresponding energy layer.
    const std::vector<int>*
    get_nb_spots_per_layer(void) const {
        return &nb_spots_per_layer_;
    }

    /// \brief Returns a constant pointer to the spot sequence vector.
    ///
    /// \return A pointer to a vector containing all the spots in delivery order.
    const std::vector<spot>*
    get_sequence(void) const {
        return &sequence_;
    }

    /// \brief Returns the tune ID of the beam model.
    ///
    /// \return A constant string containing the tune ID.
    const std::string
    get_tune_id(void) const {
        return tune_id_;
    }

    /// \brief Prints the details of the spot sequence to the console for debugging.
    ///
    /// \details This method iterates through the spot sequence and prints the energy, position,
    /// FWHM, and meterset weight for each spot. `std::cout` is the C++ equivalent of
    /// Python's `print()` for writing to the standard output.
    void
    dump() const {
        std::cout << "dump:spotmap, size:" << sequence_.size() << std::endl;
        for (auto i : sequence_) {
            std::cout << "spot (E,X,Y,Sx,Sy,W): " << i.e << ", " << i.x << ", " << i.y << ", "
                      << i.fwhm_x << ", " << i.fwhm_y << ", " << i.meterset << std::endl;
        }
    }
};

}   // namespace mqi

#endif
